## 网络编程(python)

### 前言

吕泽
lvze@tedu.cn

3天 网络编程
4.5天 进程线程
1.5  综合

4天 MongoDB
1.25天  正则表达式
2.75天  第二阶段项目







# Day01

### 网络编程

网络目的 ： 数据的传输

网络数据传输是一个复杂的过程

ISO ：国际标准化组织

OSI 七层模型  --》 网络通信标准化流程 

应用层 ： 提供用户服务，具体内容由特定程序规定
表示层 ： 数据的压缩优化 
会话层 ： 建立应用连接，选择传输层服务
传输层 ： 提供不同的传输服务，流量控制
网络层 ： 路由选择，网络互连
链路层 ： 提供链路交换，具体消息以帧发送
物理层 ： 物理硬件，接口，网卡，线路

![](/home/nonbody/文档/网络编程/img/osi.png)

![osi1](/home/nonbody/文档/网络编程/img/osi1.png)



osi七层模型优点 ： 将功能分开，降低了网络传输中的耦合性，每一部分完成自己的功能。可以在开发和实施的过程中各司其职。

cookie

高内聚 ： 单个模块功能尽量单一
低耦合 ： 模块之间尽量减少关联和影响

四层 
应用层 ：  应用层   表示层  会话层
传输层 ：  传输层
网络层 ：  网络层
物理链路层： 链路层和物理层



![osi2](/home/nonbody/文档/网络编程/img/osi2.png)



五层（tcp/ip模型）
应用层 ： 应用层   表示层  会话层
传输层 ： 传输层
网络层 ： 网络层
链路层 ： 链路层
物理层 ： 物理层

协议（网络协议）：在网络通信中，各方必须遵守的规定。包括建立什么样的连接，消息结构等 

![](/home/nonbody/文档/网络编程/img/tcp.png)

应用层 ： TFTP   HTTP  DNS   SMTP
传输层 ： TCP   UDP
网络层 ： IP 
物理层 ： IEEE

![](/home/nonbody/文档/网络编程/img/tcp45.png)


网络基本概念

主机：   "localhost"   表示本台计算机

网络上 ：  只在本地测试使用
           'localhost'    '127.0.0.1'

	   如果想在网络上进行测试
	   '0.0.0.0'   ''   '172.60.50.93'

##### cookie 
查看 IP网络信息
linux    ifconfig 
win      ipconfig

获取计算机名称
In [2]: socket.gethostname()
Out[2]: 'tedu'

获取主机IP
In [5]: socket.gethostbyname('localhost')
Out[5]: '127.0.0.1'



IP地址
在网络上用于区分一台计算机

IPv4 ： 点分十进制    e.g.  192.168.1.72   0-255
        32位二进制表示 

IPv6 ： 128

网络连接测试命令：  ping  172.60.50.92

特殊IP
127.0.0.1   本地测试IP
0.0.0.0    本地网卡通用IP
192.168.1.0   表示当前网段
192.168.1.1   表示网关
192.168.1.255  广播地址

获取服务主机信息

```
In [7]: socket.gethostbyaddr("www.baidu.com")
Out[7]: ('127.0.0.1', [],   ['119.75.213.61'])
```

          主机        别名   IP地址

```
将ip十进制转化为二进制
In [12]: socket.inet_aton("192.168.1.2")
Out[12]: b'\xc0\xa8\x01\x02'
```

```
将ip二进制转化为十进制
In [11]: socket.inet_ntoa(b"\xc0\xa8\x01\x02")
Out[11]: '192.168.1.2'
```

域名 ： 网络服务器IP地址的名称
url ： 在网络上定位某个资源位置的字串

端口号 ： 端口号是网络地址的一部分，在一个系统中，每个网络应用都会有一个唯一的端口号，取来区别其他应用，接受发往这个端口的消息。

数字范围 ： 1--65535

1--255 ： 一些众所周知的端口
256--1023 ： 系统应用
1024---65535 ： 自用 
推荐  >10000   8888   9999   7777   6666

```
测试一个软件端口号
In [13]: socket.getservbyname('mysql')
Out[13]: 3306
```

#### 传输层服务(TCP/UDP协议)



面向连接的传输服务 ---》 tcp协议

传输特征：
- 提供可靠的传输服务
  可靠性表现： 数据在传输过程中，无失序，无差错，无重复，无丢失

- 传输过程中有建立和断开连接的过程

##### 三次握手四次挥手

三次握手：建立数据传输两端的持续连接

```
1. 客户端向服务器发起连接请求
2. 服务器收到连接请求进行确认，返回报文
3. 客户端收到服务器确认进行连接创建
```

![woshou](/home/nonbody/文档/网络编程/img/woshou.png)

四次挥手：断开连接的两端，保证数据的传输完整

```
1.主动方发送报文，告知被动方要断开连接
2.被动方返回报文，告知收到请求，准备断开
3.被动方再次发送报文，告知准备完毕可以断开
4.主动方发送报文完成断开
```

![](/home/nonbody/文档/网络编程/img/huishou.png)

适用情况：文件的上传下载，网络情况良好，需要必须保证可靠性的情况
比如 ： 信息聊天，文件上传下载，邮件，网页获取

面向无连接的传输服务 ---》 udp协议

传输特征 ：
```
- 不保证传输的可靠性
- 无需建立三次握手和四次挥手的连接断开过程
- 消息的收发比较自由，不受其他约束
```

      适用情况 ： 网络情况较差，对可靠性要求不高，收发消息的两端不适合建立固定连接  

![UDP](/home/nonbody/文档/网络编程/img/UDP.PNG)

比如 ：网络视频，群聊，发送广播

问题总结 ：
```
1. osi模型
2. 三次握手和四次挥手
3. tcp和udp的区别
```

#### socket套接字编程

 目的 ： 通过编程语言提供的函数接口进行组合，更简单的完成基于tcp和udp通信的网络编程

套接字：完成上述目标的编程方法方案

![](/home/nonbody/文档/网络编程/img/TCP1.PNG)

##### 套接字的分类

| 套接字的分类                      |                             |
| :-------------------------------- | --------------------------- |
| 流式套接字（SOCK_STREAM）   ：    | 传输层基于tcp的协议进行通信 |
| 数据报套接字（SOCK_DGRAM）：      | 传输层基于udp的协议进行通信 |
| 底层套接字（SOCK_RAM）          : | 访问底层协议的套接字        |

###### TCP套接字

import  socket

1. 创建套接字

```
socket.socket(socket_family = AF_INET,
              socket_type = SOCK_STREAM,
	      proto = 0)
功能：创建一个套接字
参数： socket_family   选择地址族类型  AF_INET 表示IPv4
       socket_type     选择套接字类型  SOCK_STREAM 流式
                                       SOCK_DGRAM  数据报
        proto          通常为0 （表示选择子协议）
返回值： 返回一个套接字对象
```



2. 绑定IP端口

   ```
   sockfd.bind()
   功能 ： 绑定IP和端口
   参数： 二元元组，第一项为ip 第二项为端口号
                    e.g. ("192.168.1.2",8888)
   ```

3. 将套接字设置为可监听

  ```
  sockfd.listen(n)
  功能：将套接字设置为监听套接字，并设置监听队列
  参数： 监听对象的大小   n为大于0 的正整数
  ```

4. 等待客户端的连接

  ```
  1. connfd,addr = sockfd.accept()
  功能： 阻塞等待客户端连接
  返回值 ：connfd  一个新的套接字，用于和指定客户端通信
         addr    连接的客户端的地址
  
  * 阻塞函数： 程序运行到阻塞函数位置，如果某种预期条件没有达成则暂停继续运行，直到条件达成后再继续运行
  ```

![](/home/nonbody/文档/网络编程/img/5.png)

5.消息收发

```
data = connfd.recv(buffersize)
功能 ： 接收消息
参数 ： 每次最多接收的消息大小  bytes
返回值 ： 返回接收到的内容    decode()

n = connfd.send(data)
功能 ： 发送消息
参数 ： 要发送的内容  必须是bytes格式   encode()
返回值 ： 实际发送的字节数
```

6.关闭套接字

```
close()
功能 ： 关闭套接字，tcp连接断开

* telnet  ip   port   表示连接tcp服务端
```



###### TCP客户端



1.创建套接字

```
socket()

- 通信的两端套接字类型相同
```

2. 发起连接

  ```
  connect()
  功能 ： 发起连接请求
  参数 ： 元组，服务器端的地址
  ```

3.发收消息

```
send  recv

* 两端收发需要配合
```

4.关闭套接字

```
close（）
```

![TCP_Client](/home/nonbody/文档/网络编程/img/TCP_Client.PNG)

###### TCP服务端

![TCP_Server](/home/nonbody/文档/网络编程/img/TCP_Server.PNG)

作业 ： 

```
1. 口述三个问题
2. 将tcp服务端和客户端改写为可以循环收发的模式，当发送##时两端都退出
3. 当客户端退出后，服务端可以继续等待连接其他客户端，进行操作
```



----

### day01回顾

前情回顾

1.osi七层模型是什么？
2.三次握手和四次挥手？
3.tcp和udp的区别和关系？

网络基本概念 ： 主机   端口    ip
套接字 ： 网络编程方式

流式套接字 ----》 tcp
数据报套接字 ---》 udp

tcp服务端流程
socket() --》 bind() --》 listen() --> accept() --> recv()/send() --> close()

***************************************************

# Day02

recv()特征

```
1. 如果连接端断开，recv会立即结束阻塞返回空字符串
2. 当接收缓冲区为空时会阻塞
3. 如果recv一次接受不完缓冲区内容，下次会继续接受，确保数据不丢失
```

send()特性

```
1.如果另一端不存在还试图使用send进行发送则会产生BrokenPipeError异常
2.当发送缓冲区满时会阻塞
```


网络收发缓冲区

```
*缓冲区的功能 ： 协调读写速度，减少和磁盘交互

recv和send实际上是从缓冲区内获取内容，和向缓冲区发送内容
```

tcp粘包

```
产生原因：tcp传输采用字节流的方式，消息之间没有边界，如果发送和接受速度不匹配，会造成多次发送的内容被一次接受，形成意义上的误解即粘包

产生条件 ： 当使用send快速的连续发送极有可能产生粘包。

影响： 如果每次发送的内容代表一个独立的意思，此时产生粘包需要处理。但是如果多次发送的内容本身就是一个连续的整体，此时就不需要处理
```

	如何处理 ： 

```
1. 每次发送后加一个结尾标志，接收端通过标志进行判断
2. 发送一个数据结构
3. 每次发送中间有一个短暂的延迟
```

#### 基于udp的通信

##### UDP服务端

1. 创建套接字 ---》 数据报套接字
    sockfd = socket(AF_INET,SOCK_DGRAM)

2. 绑定服务端地址
    sockfd.bind()

3. 消息的收发

```
data,addr = recvfrom(buffersize)
功能 ： 接受udp消息
参数 ： 每次最多接收消息的大小
返回值 ： data  接收到的消息
          addr  消息发送者的地址

sendto(data,addr)
功能： udp发送消息
参数： data要发送的消息   bytes
       addr 目标地址
返回值 ： 发送的字节
```



4.关闭套接字

```
sockfd.close()

cookie 

sys.argv
功能 ： 获取来自命令行的参数，形成一个列表

- 以空格作为每一项分隔，如果一项中有空格则用引号表   示一个整体
- 命令行内容均作为字符串传入
```

![UDP_Server](/home/nonbody/文档/网络编程/img/UDP_Server.PNG)

##### UDP客户端

1. 创建套接字
2. 消息收发
3. 关闭套接字

tcp流式套接字 和 udp数据报套接字 区别
```
1. 流式套接字采用字节流的方式传输数据，而数据报套接字以数据报形式传输
2. tcp会产生粘包现象，udp消息是有边界的不会粘包
3. tcp传输是建立在连接的基础上，保证传输的可靠性，而udp一次接受一个数据报，不保证完整性
4. tcp需要依赖listen accept建立连接，udp不用
5. tcp 收发消息使用recv send udp用recvfrom sendto
```

![UDP_Client](/home/nonbody/文档/网络编程/img/UDP_Client.PNG)

###### 补充：

sendall()

```
功能 ： 同send() 作为tcp消息发送
参数 ： 同send()
返回值 ： 发送成功返回None ，发送失败返回异常
```

socket模块和套接字属性

```
（s表示一个套接字对象）

s.type  :  获取套接字类型
s.family : 获取地址族类型

s.fileno()
功能 ： 获取套接字的文件描述符
文件描述符 ：每一个IO操作系统都会为其分配一个不同 的正整数，该正整数即为此IO操作的文件描述符。 

s.getsockname()
功能 ： 获取套接字绑定地址

s.getpeername()
功能 ： 获取连接套接字另一端的地址

s.setsockopt(level,optname,value)
功能：设置套接字选项  丰富修改原有套接字功能
参数： level ： 获取选项的类型
       optname ： 每个选项类型中的子选项
       value :  为选项设置值
       
s.getsockopt(level,optname)
功能 ： 获取套接字选项的值
```




udp套接字应用之广播

一点发送多点接收

```
目标地址 ： 广播地址，每个网段内最大的地址
172.60.50.255   ----》 <broadcast>
```

cookie 
	format()
	功能：合成字符串


tcp应用之HTTP传输

```
http协议 ---》 超文本传输协议   应用层协议

用途 ： 网页的获取，基于网站的数据传输
        基于http协议的数据传输
```

特点： 

```
1. 应用层协议，传输层使用tcp传输
2. 简单灵活，和多种语言对接方便
3. 无状态协议，不记录用户的通信内容
4. 成熟稳定 http1.1 
```

工作模式 ： 

```
- 使用http双方均遵循http协议规定发送接收消息体
- 请求方，根据协议组织请求内容发送给对方
- 服务方，收到内容按照协议解析
- 服务方，将回复内容按照协议组织发送给请求方
- 请求方，收到回复根据协议解析
```

![网站访问流程](/home/nonbody/文档/网络编程/img/网站访问流程.png)

http请求
http响应


作业 ：  

	 	写一个tcp服务端和客户端，完成一个文件的传输过程
	 了解http协议更多的内容

### day02回顾

前情回顾
1. recv和send特性
2. tcp  粘包  处理粘包的方法
3. udp 套接字使用  recvfrom   sendto
4. 套接字属性 fileno    getpeername   setsockopt
5. 广播
6. HTTP协议  
    * 什么是http协议 
    * http协议的使用过程
    * HTTP协议的特点

*************************************************
# Day03

### HTTP请求   Request

请求格式：

请求行  

  GET          /         HTTP/1.1
 请求种类    请求内容       协议版本

    请求种类 ： 
    	GET    获取网络资源
        POST   提交一定的附加数据，得到返回结果
    	HEAD   获取响应头
    	PUT     更新服务器资源
    	DELETE  删除服务器资源
    	CONNECT  预留
    	TRACE     测试
    	OPTIONS  获取服务器性能

请求头   对请求内容的具体描述

```
- 以键值对的形式对请求信息进行描述
e.g. 

 Accept: text/html
 Accept-Encoding: gzip, deflate, br
 Accept-Language: zh-CN,zh;q=0.9
 Cache-Control: max-age=0
 Connection: keep-alive
```



空行

请求体   提交具体的请求参数

###### HTTP响应    Response

响应格式 

响应行   反馈具体的响应情况

    HTTP/1.1      200        OK
    版本信息     响应码    附加信息
    
    响应码 ：  1xx   提示信息 表示请求已经接受
               2xx   响应成功
    	   3xx   响应需要重新请定向
    	   4xx   客户端错误
    	   5xx   服务器错误
    常见响应码 ： 200   成功
                      404   请求页面不存在
    	      401   没有访问权限
    	      500   服务器发生未知错误
    	      503   服务器暂时无法执行

响应头   对响应信息的具体描述

```
e.g.
Cache-Control: private
Connection: Keep-Alive
```

空行
响应体   将客户想要的内容进行返回

要求 ：  	知道什么是HTTP协议，功能特点
         	知道请求和响应的格式和作用
		知道请求头的种类，基本的响应码的意义
	 	了解http请求和响应的完整过程

#### 基础的http服务流程程序

1. 接收http请求
2. 给出一定的响应

```
通过tcp进行文件传输
read --》 send
recv -->  write
```

<u>IO   input  output</u> 
凡是在内存中存在数据交换的操作都可以认为是IO操作

```
比如：  内存和磁盘交互       读写 read write
       内存和终端交互       print   input
       内存和网路交互       recv  send  
```

| IO / CPU密集型程序           |                                                              |
| ---------------------------- | :----------------------------------------------------------- |
| IO密集型程序 ：              | 程序的执行过程中进行大量的IO操作，而只有较少的cpu运算。消耗计算机资源较少，运行时间长。 |
| CPU密集型程序（计算密集型）: | 程序运行中需要大量的cpu运算，IO操作较少。消耗cpu资源多，运行速度快 |

##### IO分类

```

阻塞IO   非阻塞IO   IO多路复用   事件IO   异步IO

阻塞IO ： 默认形态  效率很低的一种IO
```

阻塞情况 ：  * 因为某种条件没有达到造成的阻塞
              `  e.g.   input   accept   recv  `

	     * 处理IO事件的时间消耗较长带来阻塞
	            e.g. 文件的读写过程，网络数据发送过程

非阻塞IO :  

```
通过修改IO事件的属性，使其变为非阻塞状态，即避免条件阻塞的情况

- 非阻塞IO往往和循环搭配使用，这样可以不断执行部分需要执行的代码，也不影响对阻塞条件的判断
```



**设置套接字为非阻塞**

```
s.setblocking()
功能 ： 设置套接字的阻塞状态
参数 ： 设置为False则套接字调用函数为非阻塞
```

![非阻塞](/home/nonbody/文档/网络编程/img/非阻塞.png)


超时检测

将原本阻塞的IO设置一个最长阻塞等待时间，在规定时间内如果达到条件则正常执行，如果时间到仍未达到条件则结束阻塞。

```
s.settimeout(sec)
功能 ： 设置套接字超时时间
参数 ： 设置的时间
```

###### IO多路复用

```
定义 ： 同时监控多个IO事件，当哪个IO事件准备就绪就执行哪个IO事件。 此时形成多个IO时间都可以操作的现象，不必逐个等待执行。

准备就绪 ： IO事件即将发生的临界状态
```

![多路复用](/home/nonbody/文档/网络编程/img/多路复用.png)

import select 

select   ---》 windows   linux  unix
poll  ---》 linux   unix
epoll ---》 linux   unix

```
r, w, x = select(rlist, wlist, xlist[, timeout])
```

功能： <u>监控IO事件，阻塞等待IO事件发生</u>
参数

```
 	rlist  列表  存放被动等待处理的IO事件
    wlist  列表  存放需要主动处理的IO
    xlist  列表  存入如果发生异常需要处理的IO
   timeout  超时时间
```

返回值 ： 

```
r   列表   rlist中准备就绪的IO
          w   列表   wlist中准备就绪的IO
	  x   列表   xlist中准备就绪的IO
```



注意事项 ： 

```
1. IO多路复用 处理IO的过程中不应有死循环出现，使一个客户端长期占有服务端
2. IO多路复用是一种并发行为，但是是单进程程序，效率较高
```



#### 位运算

```
按照二进制位来进行运算操作

&  按位与
|  按位或
^  按位异或
<<  左移

右移

11   1011
14   1110  

11 & 14 --》10
11 | 14 --》15
11 ^ 14 --> 5
11 << 2 --> 44
14 >> 2 --> 3

使用 ： 1 在底层做硬件寄存器的操作
        2 做标志位的过滤选择 
```

![](/home/nonbody/文档/网络编程/img/byte.png)

作业 ：

```
 写一个select服务端，同时关注客户端连接，客户端发送消息，和终端输入。将客户端发送内容和终端输入的内容都写按行到一个文件里 
 sys.stdin

```



### day03回顾

前情回顾

1.HTTP协议的请求和响应
2.简单的http传输
3. IO 

     ```
     阻塞IO   默认形态
     非阻塞IO   setblocking   settimeout
     
     IO多路复用
      目的：当程序中有多个IO事件，提高程序执行效率
      方法：同时监控多个IO事件，当哪个IO事件可以执行即执行该IO
     ```

select方法
**************************************************

# Day04

##### poll

```
from select  import  poll
```



1. 创建poll对象

   p = poll()

2. 添加关注的IO

```
poll  IO 事件分类
POLLIN  POLLOUT  POLLERR  POLLHUP  POLLPRI  POLLVAL
rlist   wlist    xlist   断开连接 紧急处理  无效

p.register(s,POLLIN | POLLERR)

p.unregister(s)    取消对IO的关注
```



3. 进行监控

  ```
  1. events = p.poll()
  功能 ： 监控关注的IO，阻塞等待IO发生
  返回值 ： events是一个列表，列表中每个元素为一个元组，代表准备就绪需要处理的IO
  
  events --》 [(     fileno,        event),(),()]
                就绪IO的fileno   哪个事件就绪
  
  因为要获取IO对象调用函数---》通过fileno得到对象
  实施方法 ： 建立比照字典 {s.fileno():s}
  ```



4. 处理IO

```
epoll
使用方法 ： 与poll基本相同

- 生成对象使用epoll() 而不是poll() 
- register注册IO事件事件类型改为epoll事件类型

select   poll   epoll 区别

1. select可以很好支持windows
2. epoll比select和poll效率高，select和poll差不多
3. epoll提供了更多的触发方式
```



#### 本地套接字

linux下文件类型

```
b 块设备文件     c 字符设备文件   d 目录  

- 普通文件    l 链接   s 套接字    p  管道 

作用 ： 用于本地不同程序间进行通信
```



本地套接字创建流程：
1. 创建套接字对象

  ```
  sockfd = socket(AF_UNIX,SOCK_STREAM)
  ```

2. 绑定本地套接字文件

  ```
  sockfd.bind(path)  
  path ： 一个文件
  ```

3. 监听

4. 接受发送消息

#### cookie

```
os.path.exists(path)
功能 ： 判断一个文件夹下是否有某个文件

In [4]: os.path.exists('./tcp_client.py')
Out[4]: True
```

```
os.unlink(path)   os.remove(path)
功能 ： 删除一个文件
```

#### 多任务编程

==意义== ： 充分利用计算机的资源提高程序的运行效率

==定义== ： 通过应用程序利用计算机多个核心，达到同时执行多个任务的目的。



实施方案 ： ~~多进程   多线程~~

|         |                                                              |
| ------- | ------------------------------------------------------------ |
| 并行 ： | 多个计算机核心在同时处理多个任务，多个任务之间是并行关系     |
| 并发 ： | 计算机同时处理多个任务，内核在多个任务间不断切换，达到好像在同时处理的运行效果。此时多个任务实际为并发关系 |
| 进程 ： | 程序在计算机中运行一次的过程                                 |
| 程序 ： | 是一个可执行文件，是静态的，占有磁盘，不占有计算机运行资源   |
| 进程 ： | 进程是一个动态的过程描述，占有cpu内存等计算机资源的，有一定的生命周期 |

<u>同一个程序的不同执行过程是不同的进程，因为分配的计算机资源等均不同</u>

---



进程的创建流程

```
1.用户空间运行一个程序，发起进程创建
2.操作系统接受用户请求，开启进程创建
3.操作系统分配系统资源，确认进程状态
4.将创建好的进程提供给应用层使用
```



cpu时间片 

```
如果一个进程占有计算机核心，我们称为该进程在cpu时间片上。多个任务实际对cpu会进行争夺，一般由操作系统分配cpu时间片
```

PCB（进程控制块）

```
在操作系统中，进程创建后会自动产生一个空间存放进程信息，称为进程控制块
```

进程信息 ： 进程PID ,进程占有的内存位置，创建时间，用户......

进程 PID : 进程在操作系统中的唯一编号，大于0整数，由系统自动分配

```
进程信息查看命令 ：   ps  -aux
```



进程特征 

```
- 进程是操作系统分配计算机资源的最小单位
- 每个进程都有自己单独的虚拟内存空间
- 进程间的执行相互独立，互不影响
```



进程的状态

```
  三态
    * 就绪态：进程具备执行条件，等待系统分配cpu
    * 运行态：进程占有cpu处理器，处于运行状态
    * 等待态：进程暂时不具备运行条件，需要阻塞等           待
```

```
 五态 （增加新建态和终止态）

	- 新建态 ： 创建一个新的进程，获取资源的过程
  	- 终止态 ： 进程结束释放资源的过程
```



  ps -aux   ---> STAT 查看进程状态

     D  等待态   （不可中断等待）
     S  等待态   （可中断等待）
     T  等待态   （暂停状态）
     R  运行态   （就绪态  运行态）
     Z  僵尸态
    
     +  前台进程
     <  高优先级
     N  低优先级
     l  有进程链接
     s  会话组组长

##### 进程优先级

优先级决定了一个进程的执行权限和占有资源的优先程度

查看进程优先级

```
   top  ： 动态的查看进程优先级   <> 翻页

   取值范围： -20  --- 19     -20优先级最高

   nice  ： 指定优先级运行程序
     e.g.   nice  -9   ./while.py
            sudo nice  --9  ./while.py    -9优先级
```



父子进程

在系统中除了初始化进程每个进程都有一个父进程，可能有0个或者多个子进程。由此形成父子进程关系。我们认为每个进程都是父进程发起请求创建的。

```
进程（process）
查看进程树： pstree
查看父进程PID ：  ps  -ajx
```

![父子进程](/home/nonbody/文档/网络编程/img/父子进程.png)

要求 ：  

```
	什么是进程，进程和程序的区别
         了解进程的特征
	 清楚进程的状态及状态间的转化关系
	 并行和并发的区别，操作系统功能
```




需求 ：编写一个程序，能够同时执行多个任务。同时需要在程序运行过程中，根据情况创建进程。


import  os 

```
pid = os.fork()
功能 ： 创建一个新的进程
参数： 无
返回值： 失败返回一个负数   -1
         成功  在原有进程中返回新的进程的PID
	       在新的进程中返回0
```

```


- 子进程会复制父进程全部代码段，包括fork前的代码
- 子进程从fork的下一句开始执行
- 父子进程通常会根据fork返回值的差异选择执行不同   的代码 （使用if结构）
- 父子进程在执行上互不干扰，执行顺序不确定
- 子进程虽然复制父进程内存空间，但是有自己的特性，比如PID号，PCB等
- 父子进程空间独立，各自修改各自的内容，互不影响
```



作业 ： 

```
写一个聊天室

功能 ： 类似qq群聊

1. 进入聊天室需要输入用户名
2. 有人进入聊天室 其他人会收到提示
xxx 进入聊天室
3. 某人发消息，则其他人都能收到
xxx 说： xxxxxxxxx
4. 有人退出聊天室 其他人会收到提示
xxx 退出了聊天室

 服务端  客户端

- 整体实现方案
- 用什么技术
```

### day04回顾

前情回顾

1. poll   epoll（效率较高）
2. 本地套接字 ： AF_UNIX  本地两个进程间的通信
3. 多任务编程  
     并行，并发
     什么是进程
     进程的状态
4. 创建进程 os.fork()

*************************************************

# Day05



### 进程相关函数使用

```
os.getpid()
功能 ： 获取当前进程的PID号
返回值 ： 返回PID号

os.getppid()
功能 ： 获取父进程的进程号
返回值 ： 返回PID号

os._exit(status)
功能 ： 退出进程
参数 ： 进程的退出状态  整数

sys.exit([status])
功能： 退出进程
参数： 默认为0  如果是整数则表示退出状态
                如果是字符串则表示退出时打印内容

- sys.exit 可以通过捕获SystemExit异常阻止退出
```



###### 孤儿进程 ： 

	父进程先于子进程退出，此时子进程就会成为孤儿进程。

```
	孤儿进程会被系统指定的进程收养，即系统进程会成为   该孤儿进程新的父进程。孤儿进程退出时该父进程会处   理退出状态
```



###### 僵尸进程 ： 

	子进程先于父进程退出，父进程没有处理子             进程退出状态，此时子进程成为僵尸进程

```
	僵尸进程已经结束，但是会滞留部分PCB信息在内存，大量的僵尸会消耗系统资源，应该尽量避免
```



**如何避免僵尸进程产生**

	父进程处理子进程退出状态

```
pid,status = os.wait()
功能 ：在父进程中阻塞等待处理子进程的退出
返回值 ： pid  退出的子进程的PID号
          status  子进程的退出状态 

pid,status = os.waitpid(pid,option)
功能 ： 同wait
参数 ： pid   -1  表示任意子进程退出
              >0  整数  指定PID号的子进程退出
option   0  表示阻塞等待
       WNOHANG  表示非阻塞
返回值 ： 同wait

waitpid(-1,0) =======  wait()
```



	父进程先退出

```
创建二级子进程 

1. 父进程创建子进程等待子进程退出
2. 子进程创建二级子进程，然后马上退出
3. 二级子进程成为孤儿，处理具体事件
```




写一个聊天室

```
功能 ： 类似qq群聊

1. 进入聊天室需要输入用户名
2. 有人进入聊天室 其他人会收到提示
xxx 进入聊天室
3. 某人发消息，则其他人都能收到
xxx 说： xxxxxxxxx
4. 有人退出聊天室 其他人会收到提示
xxx 退出了聊天室
5. 管理员功能，管理员喊话聊天室所有人都能收到

 服务端  客户端

- 整体实现方案
- 用什么技术

1. 用什么技术

  socket通信   ----> 消息转发 ----》 UDP通信

  转发模式 --->  每个将消息发送给服务器，服务器发                送个每个成员

  消息收发  ---> 使用多进程让发送和接受互不影响

  存储用户  --->  字典 或者 列表 
                  姓名，地址

注意 ： 使用一定的封装性
        测试 ， 每个功能进行测试

代码编写

先搭建网络连接 --》 多进程创建 --》每个功能编写--
》功能测试

客户端

- 登录   "L name" 
服务器 ： 识别请求 判断是否可以登录
          保留用户
      将登录消息通知其他人
- 聊天   "C name message"
服务器 ： 识别请求
          将消息转发给其他人
- 退出   "Q name"
服务器 ： 识别请求
          告知其他人退出
      从结构中删除用户

服务器

multiprocessing 模块创建进程

1. 需要将要做的事件封装为函数
2. 使用multiprocessing中提供的Process类创建进程对    象
3.通过进程对象和Process 初始化函数 对进程进行设置，并且绑定要执行的事件
3. 启动进程，会自动执行相关联函数
4. 事件完成后回收进程
```



### 创建进程对象

Process()



	功能 ： 创建进程对象
	参数 ： name :  给创建的进程起一个名字
	                默认Process-1
		target : 绑定的函数
		args ： 元组 给target函数按照位置传参
		kwargs ： 字典 给target函数按照键值出传参

p.start()
功能： 启动进程，此时进程被创建。自动运行进程函数

p.join([timeout])
功能 ： 阻塞等待回收响应的进程
参数 ： 超时时间

```
- multiprocessing创建进程是原来进程的子进程，创建后父子进程各自执行互不影响
- 子进程同样是复制父进程的空间，子进程对内容的修改不会影响父进程空间
- join回收子进程，会有效的阻止僵尸进程产生
```



作业 ： 
        

	multipeocessing  对照fork
	创建父子进程，复制一个文件，父子进程各复制一半到一个新的文件中



### day05回顾

前情回顾：

1. 孤儿进程和僵尸进程
2. 如何避免僵尸进程
    wait   waitpid
    创建二级子进程

3. multiprocessing
    p = Process(target = func)
    p.start()
    p.join()

*************************************************

# Day06



通常使用multiprocessing创建进程，父进程只用作进程的创建和回收，不做其他工作。

#### multiprocessing 进程对象属性

p.start()  启动进程
p.join()   回收进程

p.is_alive()  判断进程生命周期状态 返回True False

p.name  进程名称 默认为Process-1  如果起名字则为自定义名称

p.pid  创建的进程的PID

**p.daemon**

```
默认值为False   父进程退出不会影响子进程运行
如果设置为True 则父进程退出子进程也会退出
```

```
- daemon的设置必须在start前
- 如果设置daemon为True 则不再使用join
```




创建自己的进程类

```
1. 继承Process类
2. 重写init 并且调用父类的init
3. 重写run方法，此时生成对象后 调用start就会自动运行run
```



多进程

```
优点 :  能并行执行多个任务，提高效率
        创建方便，运行独立，不受其他进程影响
	数据安全
缺点 ： 进程的创建和删除都需要消耗计算机的资源
```



进程池技术

```
产生原因 ： 如果有大量任务需要多进程完成，且可能需要频繁的创建和删除进程，给计算机带来大量的资源消耗。

原理 ： 在进程池内运行一定数量进程，通过这些进程完成进程池队列中的事件，直到事件执行完毕，减少进程不断的创建删除过程。
```



实施操作方法：
```
1. 创建进程池，在进程池中放入适当进程
2. 将事件加入到进程池队列
3. 事件不断运行，直到所有事件运行完毕
4. 关闭进程池，回收进程
```



`from multiprocessing  import  Pool`

```
pool = Pool(processes)
功能 ： 创建进程池对象
参数 ： 表示进程池中有多少进程
```

```
pool.apply_async(func，args,kwds)
功能 ： 将事件放入进程池队列
参数 ： func  要执行的事件
        args  给func用元组传参
	kwds  给func用字典传参
返回值 ： 返回事件对象 通过get()方法获取事件函数返回值
```

```
pool.apply(func，args,kwds)
功能 ： 将事件放入进程池队列
参数 ： func  要执行的事件
       args  给func用元组传参
		kwds  给func用字典传参
```



pool.close()
	功能 ： 关闭进程池，不能再添加新的事件

pool.join()
	功能 ： 阻塞等待回收进程池

```
pool.map(func,iter)
功能 ： 将要完成的事件放入进程池
参数 ： func 要完成的事件函数
        iter 可迭代对象给func传参 
返回值 ： 事件函数的返回值列表
```



cookie

```
获取文件大小
os.path.getsize(path)
功能 ： 获取一个文件的大小
参数 ： 文件
```

### 进程间通信

       `进程间由于空间独立，资源无法互相直接获取，此时在不同的进程间进行数据传递就需要专门的通信方法`

进程间通信方法（IPC）

| 管道 | 消息队列 | 共享内存 | 信号 | 信号量 | 套接字 |
| ---- | -------- | -------- | ---- | ------ | ------ |
|      |          |          |      |        |        |

###### 管道通信   Pipe 

**管道** :

```
 在内存中开辟一段空间，形成管道结构，管道对多个进程可见，进程可以对管道进行读写操作
```



multiprocess ---》 Pipe 

```
fd1,fd2 = Pipe(duplex = True)
功能 ： 创建一个管道
参数 ： 默认为双向管道
        如果设置为False 则为单向管道
返回值 ：如果双向管道，fd1 fd2都可以进行读写操作
         如果是单向管道，则fd1 只可读，fd2只可写
```

```
fd.recv()
功能 ： 从管道读取内容
返回值 ： 读到的内容

- 如果管道无内容则阻塞

fd.send(data)
功能： 向管道写入内容
参数： 要发送的内容

- 几乎可以发送所有python支持的数据
```



###### 消息队列 

队列 ： 先进先出

```
在内存中开辟队列结构空间，多个进程可以向队列投放消息，在取出的时候按照存入顺序取出
```



创建队列

```

```



```
q.full()   判断队列是否为满
q.empty()  判断队列是否为空
q.qsize()  判断当前队列有多少消息
q.close()  关闭队列
```



###### 共享内存

```
在内存中开辟一段空间，存储数据，对多个进程可见。每次写入共享内存中的数据会覆盖之前的内容
```

![共享内存](/home/nonbody/文档/网络编程/img/共享内存.png)

` from multiprocessing   import Value `

```
obj = Value(ctype,obj)
功能 ： 开辟共享内存空间
参数 ： ctype   字符串  要转变的c的数据类型
                        对比类型对照表
	obj   共享内存的初始化数据
返回 ： 共享内存对象

obj.value  表示共享内存中的值。对其修改或者使用即可

```

```
obj = Array(ctype,obj)
功能： 开辟共享内存
参数： ctype  要转化的c的类型
       obj  要存入共享内存的数据
               列表  将列表存入共享内存，数据类型       一致
	    正整数  表示开辟几个数据空间
```

|          | 管道                  | 消息队列 | 共享内存                       |
| -------- | --------------------- | -------- | ------------------------------ |
| 开辟空间 | 内存                  | 内存     | 内存                           |
| 读写方式 | [两端读写](双向/单向) | 先进先出 | 操作覆盖内存                   |
| 效率     | 一般                  | 一般     | 较快                           |
| 应用     | 多用于两端            | 使用广泛 | [复杂，需要通信](同步互斥机制) |


作业 ： 

```
1. 类的使用

	1. socket 代码总结
  	1. 进程和网路概念总结
   	2. 进程间通信方法和进程池熟练

```

### day06回顾

前情回顾

1. multiprocessing 进程对象属性
     p.name
     p.pid
     p.daemon  
2. 创建自己的进程类
     继承Process （初始化父类__init__）
     重写run

3. 进程池
    Pool() 创建进程池
    apply_async() 添加事件
    close() 关闭进程池
    join（）回收
    map()
4. 进程间通信 
    管道：  Pipe()  --> fd1,fd2   recv()  send()
    消息队列：  Queue()  q.get()  q.put()  q.full()                 q.empty()  q.qsize()  q.close()
    共享内存： Value()   obj.value
               Array()    shm[]
    套接字 
***************************************************



# Day07

##### 信号

`一个进程向另一个进程通过信号传递某种讯息，接收方在接收到信号后进行相应的处理`

```
查看信号：  kill  -l

kill  -signum  PID   给PID的进程发送一个信号
```



关于信号

```
信号名称 ： 信号的名字或者数字
信号含义 ： 信号的作用
默认行为 ： 当一个进程接收到信号时采取的行为
             终止进程，  暂停进程， 忽略产生
             
    e.g.  
SIGHUP   终端断开
SIGINT   ctrl + c
SIGQUIT  ctrl + \
SIGTSTP  ctrl + z 
SIGKILL  终止进程且不能被处理
SIGSTOP  暂停进程且不能被处理
SIGALRM  时钟信号
SIGCHLD  子进程状态改变发给父进程
```

![](/home/nonbody/文档/网络编程/img/signal.png)

![](/home/nonbody/文档/网络编程/img/signal2.png)

通过python进行信号处理

```
os.kill(pid,sig)
功能 ： 发送信号给某个进程
参数 ： pid    给哪个进程发送信号
        sig    要发送什么信号

signal.alarm(sec)
功能 ： 一定时间后给自身发送一个 SIGALRM信号
参数 ： 指定时间

* 一个进程中只能设置一个时钟，第二个时钟会覆盖之前的时间
```



### 程序执行的同步和异步

同步 ： 按照步骤一步一步顺序执行
异步 ： 在程序执行中利用内核，不影响应用层程序持续执行



	**信号是唯一的异步通信方式**

```
signal.pause()
功能： 阻塞等待一个信号的发生

signal.signal(signum,handler)
功能 ： 处理信号
参数 ： signum  : 要处理的信号
        handler ： 信号的处理方法
            SIG_DFL  表示使用默认的方法处理
            SIG_IGN  表示忽略这个信号
            func     自定义函数处理信号
               def func(sig,frame):
                    pass 
	       sig : 表示要处理的信号
               frame ： 信号的结构对象						

- signal函数是一个异步处理函数
- signal函数不能处理 SIGKILL SIGSTOP信号
- 在父进程中使用signal(SIGCHLD,SIG_IGN),这样子进程退出时会有系	统自动处理
```



##### 信号量

`给定一定的数量，对多个进程可见，并且多个进程根据信号量的多少确定不同的行为`

multiprocessing  ---》 Semaphore()

```
sem = Semaphore(num)
功能：生成信号量对象
参数： 信号量的初始值
返回值： 信号量对象

sem.acquire()   信号量数量减1  信号量为0时会阻塞
sem.release()   信号量数量加1
sem.get_value()  获取当前信号量的值
```



同步互斥机制

|             |                                  |
| ----------- | -------------------------------- |
| 目的 ：     | 解决对共有资源操作产生的争夺     |
| 临界资源 ： | 多个进程或者线程都能够操作的资源 |
| 临界区 ：   | 操作临界资源的代码段             |

同步 ： 

```
是一种合作关系，为完成某个任务，多进程或者多线程之间形成一种协调。按照约定依次执行对临界资源的操作，相互告知相互促进。
```

![tongbu](/home/nonbody/文档/网络编程/img/tongbu.png)

互斥 ： 

```
互斥是一种制约关系，当一个进程占有临界资源就会进行加锁的操作，此时其他进		   程就无法操作该临界资源。知道使用的进程进行解锁操作后才能使用。
```

![](/home/nonbody/文档/网络编程/img/huchi.png)

###### Event  事件 

multiprocessing --》 Event

```
创建事件对象
e = Event()

事件阻塞
e.wait([timeout])

事件设置
e.set()  
功能 ： 当e被set() 后 e.wait()不再阻塞

事件清除
e.clear()
功能 ： 当e被clear()后 e.wait()又会阻塞

事件判断 判断当前事件对象是否被设置
e.is_set()
```



###### 锁 Lock

multiprocessing --》 Lock

```
创建对象
lock = Lock()

lock.acquire()   上锁
lock.release()   解锁

上锁状态 ： 执行acquire（）操作会阻塞
解锁状态 ： 执行acquire（）不阻塞

with  lock： ---> 上锁
   ...
   ...
             ----》 with代码段结束即解锁
```

![进程锁](/home/nonbody/文档/网络编程/img/进程锁.png)

### 线程

什么是线程

线程也是一种多任务编程的方式，可以使用计算机多核资源。线程又被称为轻量级的进程



线程特征

```
- 线程是计算机核心分配的最小单位
- 一个进程可以包含多个线程
- 线程也是一个运行过程，也要消耗计算机资源。多个   线程共享其进程的资源和空间
- 线程也拥有自己特有的资源属性，比如指令集，TID等
- 线程无论创建还是删除还是运行资源消耗都小于进程
- 多个线程之间并行执行，互不干扰
```




threading 模块创建线程

```
threading.Thread()
功能 ： 创建线程对象
参数 ： name   线程名称
        target   线程函数
        args   元组   给线程函数传参
        kwargs  字典  给线程函数传参

t.start()   启动线程
t.join([timeout])  回收线程

线程属性 

t.is_alive()   查看线程状态
t.name   线程名称  默认Thread-1 。。。。。
t.setName()  设置线程名称
threading.currentThread()  获取当前线程对象

t.daemon 

默认情况下，主线的结束不会影响分支线程
如果设置为True 则主线程退出分支线程也会退出

设置方法：
t.daemon = True 
t.setDaemon(True)

判断daemon属性：
t.isDaemon()

- 线程daemon属性的设置在start前
- 一般设置daemon后不会在使用join
```



创建自己的线程类

```
1. 继承Thread类
2. 运行Thread类中的init方法以获取父类属性
3. 重写run方法
threadpool
```



作业 ：

```
1. 复习网路编程 （tcp  udp  http）

1. 司机和售票员的故事

- 创建父子进程，分别表示司机售票员
员捕捉到SIGINT信号，发送给司机 SIGUSER1信号，此时司机打印“老司机开车了”
   当售票员捕捉到SIGQUIT信号，发送给司机 SIGUSER2信号，此时司机打印“车速有点快， 系好安全带”
           当司机捕捉到SIGTSTP信号，给售票员发送 SIGUSER1,此时售票员打印“到站了请下车”
  - 到站后，售票员先下车（子进程先退出）,然 后司机下车

提示 ： SIGINT,SIGQUIT,SIGTSTP信号由键盘获取
        键盘会将信号发送给终端所有进程
```

### day07回顾

前情回顾

```
1.信号  

	os.kill()  signal.alarm()  pause()   

	signal(pid,handler) ---> def fun(sig,frame)

2.信号量  Semaphore
   acquire()  -1
   release()  +1
   get_value() 

1. 同步互斥机制 ： 解决对共享资源的争夺
event 事件
   e.wait()   e.set()  e.clear()
   lock  锁
   acquire() 上锁
   release() 解锁
2. 线程
threading  Thread()
t.start()
t.join()
   线程对象属性
如何自定义线程类
```



*********************************************



# Day08



### 线程通信

  通信方法 ： 

```
多个线程共用进程空间，所以进程的全局变量对进程内的线程均可见。因此使用全局变量通信是线程主要通信方法。
```

![线程通信](/home/nonbody/文档/网络编程/img/线程通信.png)

  注意事项 ： 

线程间通信更容易产生资源争夺，往往需要同步互斥机制保证通信安全



线程的同步互斥



**线程的Event事件**



```
 操作：
  e = threading.Event()
  e.wait([timeout])  如果e为设置状态则不阻塞，未设                    置则阻塞
  e.set()  将e变为设置状态
  e.clear()  将e设置去除

线程锁
  lock = threading.Lock()   创建锁
  lock.acquire()   上锁
  lock.release()   解锁

  操作原理 ： 重复上锁 acquire()会阻塞


```

Python线程的GIL问题（全局解释器锁）

```
python --》支持多线 --》同步互斥 --》加锁 --》超级锁（给解释器加锁）

后果 ： 一个解释器，同一时刻只能解释一个线程。大大降低了python多线程的执行效率。
```



Python 的GIL问题  解决方案
```
- 尽量使用进程
- 不使用c作为解释器    c#  java解释器
- Python线程适用于高延迟的IO操作，网络操作，不适合   cpu密集型或者传输速度很快的IO操作

注意 ： 线程遇到阻塞会让出解释器
```

```
效率测试

Line cpu: 8.739792823791504
Line IO: 3.6495778560638428

Thread cpu: 8.99168848991394
Thread IO: 3.8062639236450195

Process cpu: 4.482893943786621
Process IO: 2.1754744052886963
```



###### 进程和线程的区别和联系：

```
- 两者都是多任务编程的方式，都能够使用计算机多核资源
- 进程创建和删除要比线程消耗更多计算机资源。
- 进程空间独立数据安全性好，有专门的通信方法。
- 线程使用全局变量通信，更加简单，但是往往需要同步互斥操作
- 一个进程可以包含多个线程，线程共享进程资源
- 进程线程都有自己的特有属性资源，如命令、id等
```



使用场景:

```
  如果需要创建较多的并发，任务比较简单，线程比较适合
  如果数据操作和功能比较独立，此时使用进程比较合适
  使用线程时需要考虑到同步互斥复杂程度
  python线程要考虑到GIL问题
```



总结：

```
  进程线程的特征
  进程线程区别和关系？
  同步互斥的意义，用过什么方法，什么情况下用？
  进程间通信方式都知道哪些，有什么特点？
  僵尸进程怎么处理，线程GIL问题怎么看？
  给一个情景，问选择进程还是线程，为什么？
```




服务器模型

硬件服务器:  主机   集群

厂商  : IBM  HP  联想  浪潮


软件服务器：编写的服务端程序，依托于硬件服务器运             行，提供给用户一定的软件服务

分类 ： 

```
	webserver  --> 网站后端程序提供网站请求的后端处理和响应
    httpserver --》 处理HTTP请求，回复http响应
	邮箱服务器 --》 处理邮件
	文件服务器 --》 处理文件传输
```



功能 ： 

	网络连接，逻辑处理 ，数据的交互，
        数据的传输，协议的实现

模型结构 ： 

		c/s  (客户端服务器模型)
           	b/s  （浏览器服务器模型）

服务器目标 ： 处理速度快， 数据更安全，并发量大

硬件 ：更高的配置，集成分布基础，更好的网路速度，        更多主机，更好的网路安全性

软件 ： 程序占有更少的资源，更稳定的运行效果，更         流畅的运行速度，采用更安全更合适的技术




基础的服务器模型

循环服务器 ：

单进程程序，循环接受客户端请求，处理请求，每处理完一个请求再去接受下一个请求。
     

     优点 ： 实现简单，占用资源少
     缺点 ： 无法同时连接多个客户端，当一个客户端务器时，形成其他客户端			无法操作的情况
     使用情况 ： 任务比较短暂，udp套接字更合适


并发服务器：同时处理多个客户端的任务请求

    IO并发： IO多路复用协程
    
    优点 ： 资源消耗少，效率较高，适用于IO类型服务器
    缺点 ： 不能监控cpu密集型程序，本质是单进程所以不能长期阻塞消息的收发


    多进程/多线程并发 ： 为每一个客户端单独提供一个进程或者线程处理请求。由于进程线程执行独立所以对其他进程不会有影响
      
     优点 ： 客户端可以长期占有服务器，操作不会对其他进程线程产生影响
     缺点 ： 消耗资源较多

#### 多进程并发

```
使用fork完成并发

1. 创建套接字，绑定 ，监听
2. 等待接受客户端请求  accept
3. 创建子进程处理客户端请求
父进程继续等待其他客户端连接
4. 客户端退出则子进程退出
```



**tftp文件服务器**

```
功能要求：

- 客户端有简单的命令提示界面
- 根据提示选择相应的功能 
  1. 查看服务器文件库的文件列表（只显示普通文件）
  2. 下载其中的某个文件到本地
  3. 可以将本地文件上传到文件库中
  4. 退出
- 服务器需求： 1.处理客户端各种请求
    2.允许多个客户端同时访问操作

1. 技术分析 
用什么套接字   tcp
需要什么服务器模型   多进程并发
需要注意的问题  粘包  僵尸进程 
数据如何传输   文件名传输 注意粘包处理
                文件传输注意传输结尾
2. 设计整体结构
要求封装为类，将功能函数写类中
   class TFTPServer（）：
      def init():
    交互套接字
 def do_list()
 def do_get()
 def do_put()
   main（）函数控制整体流程
  创建套接字
  接受客户端连接
  创建子进程
  父进程继续等待连接
```



作业 ： 

```
1.客户端框架完成与服务端交互
2. 写get或者put
```



### day08回顾

前情回顾

线程 ：

```
   线程间的通信 ---》 全局变量
   线程同步互斥方法---》Event  Lock
   python线程的GIL --》 python线程效率低下的原因
```



进程和线程的区别和联系，使用情况

服务器 ：
     服务器概念辨析  

     循环服务器 ： 同一时刻只能处理一个客户端
     并发服务器 ： 同时可以处理多个客户端请求
     	IO 并发 ---》 io多路复用
     	多进程并发 ---》 fork

tftp文件服务器

*************************************************

# Day09

#### cookie 

```
os.listdir(PATH)

os.path.isfile(): 判断一个文件的类型是否为普通文件  
os.path.isdir()： 判断一个文件的类型是否为目录
```

### threading 的多线程并发



每有一个客户端就创建一个新的线程处理客户端请求

```
  对比多进程
优点 ： 资源消耗少
缺点 ： 需要处理共享资源
        注意GIL问题
```

实现步骤
```
1. 创建套接字，绑定，监听
2. 接收客户端请求，创建新的线程
3. 主线程继续等待其他客户端连接，分支线程执行客户端请求
4. 处理完客户端请求后，分支线程退出，关闭客户端套接字
```



socket 服务器的继承模块

python2  SocketServer
python3  socketserver

功能 ： 通过模块的接口完成基于多进程/多线程的tcp/udp的socket并发程序

```
'StreamRequestHandler',    处理tcp请求
'DatagramRequestHandler',  处理udp请求

'ForkingMixIn',       建立多进程
'ForkingTCPServer',   建立多进程tcp server
'ForkingUDPServer',   建立多进程udp server

'ThreadingMixIn',     建立多线程
'ThreadingTCPServer',  建立多线程tcp server
'ThreadingUDPServer',  建立多线程udp server

'TCPServer',    建立tcp server
'UDPServer',    建立udp server
```



### 基于多线程并发的HTTPServer

1. 接收浏览器的http请求
2. 对请求进行解析
3. 根据解析判断请求内容
4. 将要返回的内容组织http响应格式发送给客户端

```
升级 ： 

- 使用多线程并发
- 增加具体请求解析
- 增加数据获取功能
- 封装使用类
```



技术实现 ： 

```
	threading  并发
    tcp socket 传输
	HTTP协议响应和请求的格式
```



作业 ： 

```
1. 总结进程线程和网络中的概念问答题
2. 聊天室，tftp文件服，httpserver第二版
3. 复习规划
```

